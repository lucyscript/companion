name: Unstick Draft PRs

# Runs every 5 minutes to catch Copilot draft PRs and process them.
# Also available as manual dispatch.
# Needed because pull_request_target workflows require approval for bot PRs.
on:
  schedule:
    - cron: '*/5 * * * *'
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write
  actions: write

jobs:
  unstick:
    runs-on: ubuntu-latest
    env:
      AGENT_PAT: ${{ secrets.AGENT_PAT }}
    steps:
      - name: Process all Copilot draft PRs
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.AGENT_PAT || secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            // List all open PRs
            const { data: prs } = await github.rest.pulls.list({
              owner, repo,
              state: 'open',
              per_page: 100,
            });

            const copilotPRs = prs.filter(pr =>
              pr.user.login === 'Copilot' || pr.user.login === 'copilot-swe-agent[bot]'
            );

            core.info(`Found ${copilotPRs.length} open Copilot PRs`);

            for (const pr of copilotPRs) {
              core.info(`\n--- PR #${pr.number}: ${pr.title} (draft: ${pr.draft}) ---`);

              // Skip PRs where Copilot is still actively working
              // Check if there are actual file changes
              const { data: files } = await github.rest.pulls.listFiles({
                owner, repo,
                pull_number: pr.number,
              });

              if (files.length === 0) {
                core.info(`  Skipping: 0 files changed — agent is still working`);
                continue;
              }

              core.info(`  ${files.length} file(s) changed — processing`);

              // Step 1: Mark ready for review if draft
              if (pr.draft) {
                try {
                  const mutation = `mutation($id: ID!) {
                    markPullRequestReadyForReview(input: { pullRequestId: $id }) {
                      pullRequest { id number isDraft }
                    }
                  }`;
                  await github.graphql(mutation, { id: pr.node_id });
                  core.info(`  Marked PR #${pr.number} as ready for review`);
                } catch (err) {
                  core.warning(`  Could not mark ready: ${err.message}`);
                  continue;
                }
              }

              // Step 2: Approve workflow runs
              try {
                const runs = await github.rest.actions.listWorkflowRunsForRepo({
                  owner, repo,
                  head_sha: pr.head.sha,
                  status: 'action_required',
                });
                for (const run of runs.data.workflow_runs) {
                  try {
                    await github.rest.actions.approveWorkflowRun({ owner, repo, run_id: run.id });
                    core.info(`  Approved workflow run ${run.id}`);
                  } catch (err) {
                    core.warning(`  Could not approve run ${run.id}: ${err.message}`);
                  }
                }
              } catch (err) {
                core.warning(`  Failed listing runs: ${err.message}`);
              }

              // Step 3: Add labels
              try {
                const labels = pr.labels.map(l => l.name);
                const toAdd = [];
                if (!labels.includes('agent-task')) toAdd.push('agent-task');
                if (!labels.includes('agent-automerge')) toAdd.push('agent-automerge');
                if (toAdd.length > 0) {
                  await github.rest.issues.addLabels({
                    owner, repo,
                    issue_number: pr.number,
                    labels: toAdd,
                  });
                  core.info(`  Added labels: ${toAdd.join(', ')}`);
                }
              } catch (err) {
                core.warning(`  Label error: ${err.message}`);
              }

              // Step 4: Check for merge conflicts — close if unmergeable
              const { data: prDetail } = await github.rest.pulls.get({
                owner, repo,
                pull_number: pr.number,
              });

              if (prDetail.mergeable === false) {
                core.warning(`  PR #${pr.number} has merge conflicts — closing`);
                await github.rest.pulls.update({
                  owner, repo,
                  pull_number: pr.number,
                  state: 'closed',
                });

                // Find and reassign the linked issue to trigger a fresh attempt
                const bodyMatch = pr.body && pr.body.match(/(?:Fixes|Closes|Resolves)\s+#(\d+)/i);
                if (bodyMatch) {
                  const issueNumber = parseInt(bodyMatch[1]);
                  core.info(`  Reassigning linked issue #${issueNumber} to Copilot`);
                  try {
                    // Remove existing assignees first
                    const { data: issue } = await github.rest.issues.get({ owner, repo, issue_number: issueNumber });
                    const currentAssignees = issue.assignees.map(a => a.login);
                    if (currentAssignees.length > 0) {
                      await github.rest.issues.removeAssignees({
                        owner, repo,
                        issue_number: issueNumber,
                        assignees: currentAssignees,
                      });
                    }

                    // Wait for unassign event to register
                    await new Promise(r => setTimeout(r, 2000));

                    // Re-assign via agent_assignment API (requires AGENT_PAT)
                    const token = process.env.AGENT_PAT || process.env.GITHUB_TOKEN;
                    const response = await fetch(
                      `https://api.github.com/repos/${owner}/${repo}/issues/${issueNumber}/assignees`,
                      {
                        method: 'POST',
                        headers: {
                          'Authorization': `token ${token}`,
                          'Accept': 'application/vnd.github+json',
                          'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                          assignees: ['copilot-swe-agent[bot]'],
                          agent_assignment: {
                            target_repo: `${owner}/${repo}`,
                            base_branch: 'main',
                          },
                        }),
                      }
                    );
                    if (!response.ok) {
                      core.warning(`  Agent assignment API returned ${response.status}`);
                    }
                    await github.rest.issues.createComment({
                      owner, repo,
                      issue_number: issueNumber,
                      body: `PR #${pr.number} was closed due to merge conflicts. Reassigning to Copilot for a fresh attempt.`,
                    });
                    core.info(`  Reassigned issue #${issueNumber}`);
                  } catch (err) {
                    core.warning(`  Could not reassign issue: ${err.message}`);
                  }
                } else {
                  core.info(`  No linked issue found in PR body`);
                }
                continue;
              }

              // Step 5: Approve PR
              try {
                await github.rest.pulls.createReview({
                  owner, repo,
                  pull_number: pr.number,
                  event: 'APPROVE',
                  body: 'Auto-approved: unsticking Copilot draft PR.',
                });
                core.info(`  Approved PR #${pr.number}`);
              } catch (err) {
                core.warning(`  Could not approve: ${err.message}`);
              }

              // Step 6: Wait and merge
              await new Promise(r => setTimeout(r, 5000));
              try {
                await github.rest.pulls.merge({
                  owner, repo,
                  pull_number: pr.number,
                  merge_method: 'squash',
                });
                core.info(`  Merged PR #${pr.number}`);
              } catch (err) {
                core.warning(`  Merge not ready: ${err.message}`);
                core.info(`  Will retry on next scheduled run.`);
              }
            }

            core.info(`\nDone. Processed ${copilotPRs.length} Copilot PRs.`);
