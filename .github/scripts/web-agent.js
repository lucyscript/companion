#!/usr/bin/env node

/**
 * Web Agent - Playwright-based agent
 * 
 * This agent uses Playwright to interact with web-based AI interfaces
 * (ChatGPT, Claude, Gemini) when API access is unavailable or limited.
 * 
 * Usage: Set credentials as environment variables or manually log in once
 */

const fs = require('fs');
const path = require('path');
const { chromium } = require('playwright');

const ISSUE_NUMBER = process.env.ISSUE_NUMBER || '';
const ISSUE_TITLE = process.env.ISSUE_TITLE || '';
const ISSUE_BODY = process.env.ISSUE_BODY || '';
const AGENT_TYPE = process.env.AGENT_TYPE || 'chatgpt';

console.log('ðŸŒ Web Agent Started');
console.log(`ðŸ“‹ Issue #${ISSUE_NUMBER}: ${ISSUE_TITLE}`);
console.log(`ðŸ¤– Using: ${AGENT_TYPE}`);

/**
 * Agent configurations
 */
const agentConfigs = {
  chatgpt: {
    url: 'https://chat.openai.com/',
    name: 'ChatGPT',
    inputSelector: 'textarea[placeholder*="Message"]',
    submitSelector: 'button[data-testid="send-button"]',
    responseSelector: '.markdown',
    requiresLogin: true
  },
  claude: {
    url: 'https://claude.ai/new',
    name: 'Claude',
    inputSelector: 'div[contenteditable="true"]',
    submitSelector: 'button[aria-label*="Send"]',
    responseSelector: '.font-claude-message',
    requiresLogin: true
  },
  gemini: {
    url: 'https://gemini.google.com/',
    name: 'Gemini',
    inputSelector: 'textarea',
    submitSelector: 'button[aria-label*="Send"]',
    responseSelector: '.model-response',
    requiresLogin: false
  }
};

/**
 * Main web agent execution
 */
async function main() {
  const config = agentConfigs[AGENT_TYPE];
  
  if (!config) {
    console.error(`âŒ Unknown agent type: ${AGENT_TYPE}`);
    process.exit(1);
  }
  
  console.log(`ðŸŒ Launching ${config.name}...`);
  
  const browser = await chromium.launch({
    headless: true, // Set to false for debugging
    args: ['--no-sandbox', '--disable-setuid-sandbox']
  });
  
  try {
    const context = await browser.newContext({
      viewport: { width: 1280, height: 720 },
      userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
    });
    
    const page = await context.newPage();
    
    // Navigate to agent
    console.log(`ðŸ“¡ Connecting to ${config.url}...`);
    await page.goto(config.url, { waitUntil: 'networkidle', timeout: 30000 });
    
    // Check if login is required
    if (config.requiresLogin) {
      const isLoggedIn = await checkIfLoggedIn(page, config);
      
      if (!isLoggedIn) {
        console.log('âš ï¸  Not logged in. Web agent requires manual login setup.');
        console.log('   Run this workflow manually and log in through the browser.');
        console.log('   Session will be saved for future runs.');
        
        // In production, you would:
        // 1. Store auth cookies/tokens as secrets
        // 2. Use them to authenticate
        // 3. Or use a persistent browser context
        
        await browser.close();
        process.exit(1);
      }
    }
    
    console.log('âœ… Connected to agent');
    
    // Prepare prompt
    const prompt = buildPrompt({
      title: ISSUE_TITLE,
      body: ISSUE_BODY,
      number: ISSUE_NUMBER
    });
    
    console.log('ðŸ’¬ Sending prompt to agent...');
    
    // Send message
    await page.waitForSelector(config.inputSelector, { timeout: 10000 });
    await page.fill(config.inputSelector, prompt);
    await page.click(config.submitSelector);
    
    // Wait for response
    console.log('â³ Waiting for agent response...');
    await page.waitForSelector(config.responseSelector, { timeout: 60000 });
    
    // Give it time to complete
    await page.waitForTimeout(5000);
    
    // Extract response
    const response = await page.locator(config.responseSelector).last().textContent();
    console.log('ðŸ“ Received response from agent');
    
    // Parse and apply changes
    const result = parseAgentResponse(response);
    
    if (result.success) {
      console.log(`âœ… Applied ${result.files.length} file changes`);
      result.files.forEach(f => console.log(`   - ${f}`));
    } else {
      console.log('âš ï¸  Could not parse agent response into code changes');
      console.log('   Creating documentation of the response instead...');
      
      // Save response as documentation
      const docPath = path.join(process.cwd(), 'docs', `agent-response-${ISSUE_NUMBER}.md`);
      fs.writeFileSync(docPath, `# Agent Response for Issue #${ISSUE_NUMBER}

## Issue
${ISSUE_TITLE}

## Agent Response (${config.name})
${response}

---
Generated by web agent on ${new Date().toISOString()}
`);
      console.log(`   Saved response to: docs/agent-response-${ISSUE_NUMBER}.md`);
    }
    
    await browser.close();
    console.log('âœ… Web agent execution completed');
    
  } catch (error) {
    console.error('âŒ Web agent error:', error.message);
    await browser.close();
    process.exit(1);
  }
}

/**
 * Check if user is logged in
 */
async function checkIfLoggedIn(page, config) {
  try {
    // Wait a bit for page to load
    await page.waitForTimeout(2000);
    
    // Check if we can find the input selector (indicates logged in)
    const input = await page.locator(config.inputSelector).count();
    return input > 0;
  } catch (error) {
    return false;
  }
}

/**
 * Build prompt for the agent
 */
function buildPrompt(issue) {
  // Get codebase structure
  const structure = getCodebaseStructure();
  
  return `I need your help with a GitHub issue on a TypeScript project.

**Issue #${issue.number}: ${issue.title}**

Details:
${issue.body}

**Codebase Structure:**
\`\`\`
${structure}
\`\`\`

**Task:**
Please analyze this issue and provide code changes to address it.

**Output Format:**
Provide your response as structured code blocks with file paths. For example:

\`\`\`typescript:path/to/file.ts
// Full file content here
\`\`\`

Or for multiple files:

\`\`\`typescript:apps/server/src/new-agent.ts
// First file
\`\`\`

\`\`\`typescript:apps/server/src/orchestrator.ts
// Second file (modified)
\`\`\`

Please ensure:
1. Code follows existing patterns
2. TypeScript types are correct
3. Changes are minimal and focused
4. Comments explain key decisions

Generate the code changes now.`;
}

/**
 * Get codebase structure
 */
function getCodebaseStructure() {
  const { execSync } = require('child_process');
  
  try {
    const output = execSync(
      'find . -type f \\( -name "*.ts" -o -name "*.tsx" \\) ! -path "*/node_modules/*" ! -path "*/dist/*" | head -30',
      { encoding: 'utf-8', cwd: process.cwd() }
    );
    return output;
  } catch (error) {
    return 'Could not determine structure';
  }
}

/**
 * Parse agent response and extract code changes
 */
function parseAgentResponse(response) {
  const files = [];
  
  // Match code blocks with file paths
  // Format: ```language:path/to/file.ext
  const codeBlockPattern = /```(?:typescript|javascript|ts|js):([^\n]+)\n([\s\S]*?)```/g;
  
  let match;
  while ((match = codeBlockPattern.exec(response)) !== null) {
    const filePath = match[1].trim();
    const content = match[2].trim();
    
    console.log(`   ðŸ“„ Found code for: ${filePath}`);
    
    // Write file
    const fullPath = path.join(process.cwd(), filePath);
    const dir = path.dirname(fullPath);
    
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
    
    fs.writeFileSync(fullPath, content);
    files.push(filePath);
  }
  
  return {
    success: files.length > 0,
    files
  };
}

// Run web agent
main().catch(error => {
  console.error('Fatal error:', error);
  process.exit(1);
});
